// MooTools: the javascript framework.
// Load this file's selection again by visiting: http://mootools.net/more/72bff27a7ab0476a43d56f499bbcdd42 
// Or build this file again with packager using: packager build More/URI More/Form.Request
/*
 ---

 script: More.js

 name: More

 description: MooTools More

 license: MIT-style license

 authors:
 - Guillermo Rauch
 - Thomas Aylott
 - Scott Kyle
 - Arian Stolwijk
 - Tim Wienk
 - Christoph Pojer
 - Aaron Newton
 - Jacob Thornton

 requires:
 - Core/MooTools

 provides: [MooTools.More]

 ...
 */

MooTools.More = {
    'version': '1.4.0.1',
    'build': 'a4244edf2aa97ac8a196fc96082dd35af1abab87'
};


/*
 ---

 script: String.QueryString.js

 name: String.QueryString

 description: Methods for dealing with URI query strings.

 license: MIT-style license

 authors:
 - Sebastian Markbåge
 - Aaron Newton
 - Lennart Pilon
 - Valerio Proietti

 requires:
 - Core/Array
 - Core/String
 - /MooTools.More

 provides: [String.QueryString]

 ...
 */

String.implement({

    parseQueryString: function(decodeKeys, decodeValues){
        if (decodeKeys == null) decodeKeys = true;
        if (decodeValues == null) decodeValues = true;

        var vars = this.split(/[&;]/),
            object = {};
        if (!vars.length) return object;

        vars.each(function(val){
            var index = val.indexOf('=') + 1,
                value = index ? val.substr(index) : '',
                keys = index ? val.substr(0, index - 1).match(/([^\]\[]+|(\B)(?=\]))/g) : [val],
                obj = object;
            if (!keys) return;
            if (decodeValues) value = decodeURIComponent(value);
            keys.each(function(key, i){
                if (decodeKeys) key = decodeURIComponent(key);
                var current = obj[key];

                if (i < keys.length - 1) obj = obj[key] = current || {};
                else if (typeOf(current) == 'array') current.push(value);
                else obj[key] = current != null ? [current, value] : value;
            });
        });

        return object;
    },

    cleanQueryString: function(method){
        return this.split('&').filter(function(val){
            var index = val.indexOf('='),
                key = index < 0 ? '' : val.substr(0, index),
                value = val.substr(index + 1);

            return method ? method.call(null, key, value) : (value || value === 0);
        }).join('&');
    }

});


/*
 ---

 script: URI.js

 name: URI

 description: Provides methods useful in managing the window location and uris.

 license: MIT-style license

 authors:
 - Sebastian Markbåge
 - Aaron Newton

 requires:
 - Core/Object
 - Core/Class
 - Core/Class.Extras
 - Core/Element
 - /String.QueryString

 provides: [URI]

 ...
 */

(function(){

    var toString = function(){
        return this.get('value');
    };

    var URI = this.URI = new Class({

        Implements: Options,

        options: {
            /*base: false*/
        },

        regex: /^(?:(\w+):)?(?:\/\/(?:(?:([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)?(\.\.?$|(?:[^?#\/]*\/)*)([^?#]*)(?:\?([^#]*))?(?:#(.*))?/,
        parts: ['scheme', 'user', 'password', 'host', 'port', 'directory', 'file', 'query', 'fragment'],
        schemes: {http: 80, https: 443, ftp: 21, rtsp: 554, mms: 1755, file: 0},

        initialize: function(uri, options){
            this.setOptions(options);
            var base = this.options.base || URI.base;
            if (!uri) uri = base;

            if (uri && uri.parsed) this.parsed = Object.clone(uri.parsed);
            else this.set('value', uri.href || uri.toString(), base ? new URI(base) : false);
        },

        parse: function(value, base){
            var bits = value.match(this.regex);
            if (!bits) return false;
            bits.shift();
            return this.merge(bits.associate(this.parts), base);
        },

        merge: function(bits, base){
            if ((!bits || !bits.scheme) && (!base || !base.scheme)) return false;
            if (base){
                this.parts.every(function(part){
                    if (bits[part]) return false;
                    bits[part] = base[part] || '';
                    return true;
                });
            }
            bits.port = bits.port || this.schemes[bits.scheme.toLowerCase()];
            bits.directory = bits.directory ? this.parseDirectory(bits.directory, base ? base.directory : '') : '/';
            return bits;
        },

        parseDirectory: function(directory, baseDirectory){
            directory = (directory.substr(0, 1) == '/' ? '' : (baseDirectory || '/')) + directory;
            if (!directory.test(URI.regs.directoryDot)) return directory;
            var result = [];
            directory.replace(URI.regs.endSlash, '').split('/').each(function(dir){
                if (dir == '..' && result.length > 0) result.pop();
                else if (dir != '.') result.push(dir);
            });
            return result.join('/') + '/';
        },

        combine: function(bits){
            return bits.value || bits.scheme + '://' +
                (bits.user ? bits.user + (bits.password ? ':' + bits.password : '') + '@' : '') +
                (bits.host || '') + (bits.port && bits.port != this.schemes[bits.scheme] ? ':' + bits.port : '') +
                (bits.directory || '/') + (bits.file || '') +
                (bits.query ? '?' + bits.query : '') +
                (bits.fragment ? '#' + bits.fragment : '');
        },

        set: function(part, value, base){
            if (part == 'value'){
                var scheme = value.match(URI.regs.scheme);
                if (scheme) scheme = scheme[1];
                if (scheme && this.schemes[scheme.toLowerCase()] == null) this.parsed = { scheme: scheme, value: value };
                else this.parsed = this.parse(value, (base || this).parsed) || (scheme ? { scheme: scheme, value: value } : { value: value });
            } else if (part == 'data'){
                this.setData(value);
            } else {
                this.parsed[part] = value;
            }
            return this;
        },

        get: function(part, base){
            switch (part){
                case 'value': return this.combine(this.parsed, base ? base.parsed : false);
                case 'data' : return this.getData();
            }
            return this.parsed[part] || '';
        },

        go: function(){
            document.location.href = this.toString();
        },

        toURI: function(){
            return this;
        },

        getData: function(key, part){
            var qs = this.get(part || 'query');
            if (!(qs || qs === 0)) return key ? null : {};
            var obj = qs.parseQueryString();
            return key ? obj[key] : obj;
        },

        setData: function(values, merge, part){
            if (typeof values == 'string'){
                var data = this.getData();
                data[arguments[0]] = arguments[1];
                values = data;
            } else if (merge){
                values = Object.merge(this.getData(), values);
            }
            return this.set(part || 'query', Object.toQueryString(values));
        },

        clearData: function(part){
            return this.set(part || 'query', '');
        },

        toString: toString,
        valueOf: toString

    });

    URI.regs = {
        endSlash: /\/$/,
        scheme: /^(\w+):/,
        directoryDot: /\.\/|\.$/
    };

    URI.base = new URI(Array.from(document.getElements('base[href]', true)).getLast(), {base: document.location});

    String.implement({

        toURI: function(options){
            return new URI(this, options);
        }

    });

})();


/*
 ---

 script: Class.Binds.js

 name: Class.Binds

 description: Automagically binds specified methods in a class to the instance of the class.

 license: MIT-style license

 authors:
 - Aaron Newton

 requires:
 - Core/Class
 - /MooTools.More

 provides: [Class.Binds]

 ...
 */

Class.Mutators.Binds = function(binds){
    if (!this.prototype.initialize) this.implement('initialize', function(){});
    return Array.from(binds).concat(this.prototype.Binds || []);
};

Class.Mutators.initialize = function(initialize){
    return function(){
        Array.from(this.Binds).each(function(name){
            var original = this[name];
            if (original) this[name] = original.bind(this);
        }, this);
        return initialize.apply(this, arguments);
    };
};


/*
 ---

 script: Class.Occlude.js

 name: Class.Occlude

 description: Prevents a class from being applied to a DOM element twice.

 license: MIT-style license.

 authors:
 - Aaron Newton

 requires:
 - Core/Class
 - Core/Element
 - /MooTools.More

 provides: [Class.Occlude]

 ...
 */

Class.Occlude = new Class({

    occlude: function(property, element){
        element = document.id(element || this.element);
        var instance = element.retrieve(property || this.property);
        if (instance && !this.occluded)
            return (this.occluded = instance);

        this.occluded = false;
        element.store(property || this.property, this);
        return this.occluded;
    }

});


/*
 ---

 script: Class.Refactor.js

 name: Class.Refactor

 description: Extends a class onto itself with new property, preserving any items attached to the class's namespace.

 license: MIT-style license

 authors:
 - Aaron Newton

 requires:
 - Core/Class
 - /MooTools.More

 # Some modules declare themselves dependent on Class.Refactor
 provides: [Class.refactor, Class.Refactor]

 ...
 */

Class.refactor = function(original, refactors){

    Object.each(refactors, function(item, name){
        var origin = original.prototype[name];
        origin = (origin && origin.$origin) || origin || function(){};
        original.implement(name, (typeof item == 'function') ? function(){
            var old = this.previous;
            this.previous = origin;
            var value = item.apply(this, arguments);
            this.previous = old;
            return value;
        } : item);
    });

    return original;

};


/*
 ---

 script: Element.Measure.js

 name: Element.Measure

 description: Extends the Element native object to include methods useful in measuring dimensions.

 credits: "Element.measure / .expose methods by Daniel Steigerwald License: MIT-style license. Copyright: Copyright (c) 2008 Daniel Steigerwald, daniel.steigerwald.cz"

 license: MIT-style license

 authors:
 - Aaron Newton

 requires:
 - Core/Element.Style
 - Core/Element.Dimensions
 - /MooTools.More

 provides: [Element.Measure]

 ...
 */

(function(){

    var getStylesList = function(styles, planes){
        var list = [];
        Object.each(planes, function(directions){
            Object.each(directions, function(edge){
                styles.each(function(style){
                    list.push(style + '-' + edge + (style == 'border' ? '-width' : ''));
                });
            });
        });
        return list;
    };

    var calculateEdgeSize = function(edge, styles){
        var total = 0;
        Object.each(styles, function(value, style){
            if (style.test(edge)) total = total + value.toInt();
        });
        return total;
    };

    var isVisible = function(el){
        return !!(!el || el.offsetHeight || el.offsetWidth);
    };


    Element.implement({

        measure: function(fn){
            if (isVisible(this)) return fn.call(this);
            var parent = this.getParent(),
                toMeasure = [];
            while (!isVisible(parent) && parent != document.body){
                toMeasure.push(parent.expose());
                parent = parent.getParent();
            }
            var restore = this.expose(),
                result = fn.call(this);
            restore();
            toMeasure.each(function(restore){
                restore();
            });
            return result;
        },

        expose: function(){
            if (this.getStyle('display') != 'none') return function(){};
            var before = this.style.cssText;
            this.setStyles({
                display: 'block',
                position: 'absolute',
                visibility: 'hidden'
            });
            return function(){
                this.style.cssText = before;
            }.bind(this);
        },

        getDimensions: function(options){
            options = Object.merge({computeSize: false}, options);
            var dim = {x: 0, y: 0};

            var getSize = function(el, options){
                return (options.computeSize) ? el.getComputedSize(options) : el.getSize();
            };

            var parent = this.getParent('body');

            if (parent && this.getStyle('display') == 'none'){
                dim = this.measure(function(){
                    return getSize(this, options);
                });
            } else if (parent){
                try { //safari sometimes crashes here, so catch it
                    dim = getSize(this, options);
                }catch(e){}
            }

            return Object.append(dim, (dim.x || dim.x === 0) ? {
                width: dim.x,
                height: dim.y
            } : {
                x: dim.width,
                y: dim.height
            }
            );
        },

        getComputedSize: function(options){


            options = Object.merge({
                styles: ['padding','border'],
                planes: {
                    height: ['top','bottom'],
                    width: ['left','right']
                },
                mode: 'both'
            }, options);

            var styles = {},
                size = {width: 0, height: 0},
                dimensions;

            if (options.mode == 'vertical'){
                delete size.width;
                delete options.planes.width;
            } else if (options.mode == 'horizontal'){
                delete size.height;
                delete options.planes.height;
            }

            getStylesList(options.styles, options.planes).each(function(style){
                styles[style] = this.getStyle(style).toInt();
            }, this);

            Object.each(options.planes, function(edges, plane){

                var capitalized = plane.capitalize(),
                    style = this.getStyle(plane);

                if (style == 'auto' && !dimensions) dimensions = this.getDimensions();

                style = styles[plane] = (style == 'auto') ? dimensions[plane] : style.toInt();
                size['total' + capitalized] = style;

                edges.each(function(edge){
                    var edgesize = calculateEdgeSize(edge, styles);
                    size['computed' + edge.capitalize()] = edgesize;
                    size['total' + capitalized] += edgesize;
                });

            }, this);

            return Object.append(size, styles);
        }

    });

})();


/*
 ---

 script: Element.Position.js

 name: Element.Position

 description: Extends the Element native object to include methods useful positioning elements relative to others.

 license: MIT-style license

 authors:
 - Aaron Newton
 - Jacob Thornton

 requires:
 - Core/Options
 - Core/Element.Dimensions
 - Element.Measure

 provides: [Element.Position]

 ...
 */

(function(original){

    var local = Element.Position = {

        options: {/*
         edge: false,
         returnPos: false,
         minimum: {x: 0, y: 0},
         maximum: {x: 0, y: 0},
         relFixedPosition: false,
         ignoreMargins: false,
         ignoreScroll: false,
         allowNegative: false,*/
            relativeTo: document.body,
            position: {
                x: 'center', //left, center, right
                y: 'center' //top, center, bottom
            },
            offset: {x: 0, y: 0}
        },

        getOptions: function(element, options){
            options = Object.merge({}, local.options, options);
            local.setPositionOption(options);
            local.setEdgeOption(options);
            local.setOffsetOption(element, options);
            local.setDimensionsOption(element, options);
            return options;
        },

        setPositionOption: function(options){
            options.position = local.getCoordinateFromValue(options.position);
        },

        setEdgeOption: function(options){
            var edgeOption = local.getCoordinateFromValue(options.edge);
            options.edge = edgeOption ? edgeOption :
                (options.position.x == 'center' && options.position.y == 'center') ? {x: 'center', y: 'center'} :
                {x: 'left', y: 'top'};
        },

        setOffsetOption: function(element, options){
            var parentOffset = {x: 0, y: 0},
                offsetParent = element.measure(function(){
                    return document.id(this.getOffsetParent());
                }),
                parentScroll = offsetParent.getScroll();

            if (!offsetParent || offsetParent == element.getDocument().body) return;
            parentOffset = offsetParent.measure(function(){
                var position = this.getPosition();
                if (this.getStyle('position') == 'fixed'){
                    var scroll = window.getScroll();
                    position.x += scroll.x;
                    position.y += scroll.y;
                }
                return position;
            });

            options.offset = {
                parentPositioned: offsetParent != document.id(options.relativeTo),
                x: options.offset.x - parentOffset.x + parentScroll.x,
                y: options.offset.y - parentOffset.y + parentScroll.y
            };
        },

        setDimensionsOption: function(element, options){
            options.dimensions = element.getDimensions({
                computeSize: true,
                styles: ['padding', 'border', 'margin']
            });
        },

        getPosition: function(element, options){
            var position = {};
            options = local.getOptions(element, options);
            var relativeTo = document.id(options.relativeTo) || document.body;

            local.setPositionCoordinates(options, position, relativeTo);
            if (options.edge) local.toEdge(position, options);

            var offset = options.offset;
            position.left = ((position.x >= 0 || offset.parentPositioned || options.allowNegative) ? position.x : 0).toInt();
            position.top = ((position.y >= 0 || offset.parentPositioned || options.allowNegative) ? position.y : 0).toInt();

            local.toMinMax(position, options);

            if (options.relFixedPosition || relativeTo.getStyle('position') == 'fixed') local.toRelFixedPosition(relativeTo, position);
            if (options.ignoreScroll) local.toIgnoreScroll(relativeTo, position);
            if (options.ignoreMargins) local.toIgnoreMargins(position, options);

            position.left = Math.ceil(position.left);
            position.top = Math.ceil(position.top);
            delete position.x;
            delete position.y;

            return position;
        },

        setPositionCoordinates: function(options, position, relativeTo){
            var offsetY = options.offset.y,
                offsetX = options.offset.x,
                calc = (relativeTo == document.body) ? window.getScroll() : relativeTo.getPosition(),
                top = calc.y,
                left = calc.x,
                winSize = window.getSize();

            switch(options.position.x){
                case 'left': position.x = left + offsetX; break;
                case 'right': position.x = left + offsetX + relativeTo.offsetWidth; break;
                default: position.x = left + ((relativeTo == document.body ? winSize.x : relativeTo.offsetWidth) / 2) + offsetX; break;
            }

            switch(options.position.y){
                case 'top': position.y = top + offsetY; break;
                case 'bottom': position.y = top + offsetY + relativeTo.offsetHeight; break;
                default: position.y = top + ((relativeTo == document.body ? winSize.y : relativeTo.offsetHeight) / 2) + offsetY; break;
            }
        },

        toMinMax: function(position, options){
            var xy = {left: 'x', top: 'y'}, value;
            ['minimum', 'maximum'].each(function(minmax){
                ['left', 'top'].each(function(lr){
                    value = options[minmax] ? options[minmax][xy[lr]] : null;
                    if (value != null && ((minmax == 'minimum') ? position[lr] < value : position[lr] > value)) position[lr] = value;
                });
            });
        },

        toRelFixedPosition: function(relativeTo, position){
            var winScroll = window.getScroll();
            position.top += winScroll.y;
            position.left += winScroll.x;
        },

        toIgnoreScroll: function(relativeTo, position){
            var relScroll = relativeTo.getScroll();
            position.top -= relScroll.y;
            position.left -= relScroll.x;
        },

        toIgnoreMargins: function(position, options){
            position.left += options.edge.x == 'right'
                ? options.dimensions['margin-right']
                : (options.edge.x != 'center'
                ? -options.dimensions['margin-left']
                : -options.dimensions['margin-left'] + ((options.dimensions['margin-right'] + options.dimensions['margin-left']) / 2));

            position.top += options.edge.y == 'bottom'
                ? options.dimensions['margin-bottom']
                : (options.edge.y != 'center'
                ? -options.dimensions['margin-top']
                : -options.dimensions['margin-top'] + ((options.dimensions['margin-bottom'] + options.dimensions['margin-top']) / 2));
        },

        toEdge: function(position, options){
            var edgeOffset = {},
                dimensions = options.dimensions,
                edge = options.edge;

            switch(edge.x){
                case 'left': edgeOffset.x = 0; break;
                case 'right': edgeOffset.x = -dimensions.x - dimensions.computedRight - dimensions.computedLeft; break;
                // center
                default: edgeOffset.x = -(Math.round(dimensions.totalWidth / 2)); break;
            }

            switch(edge.y){
                case 'top': edgeOffset.y = 0; break;
                case 'bottom': edgeOffset.y = -dimensions.y - dimensions.computedTop - dimensions.computedBottom; break;
                // center
                default: edgeOffset.y = -(Math.round(dimensions.totalHeight / 2)); break;
            }

            position.x += edgeOffset.x;
            position.y += edgeOffset.y;
        },

        getCoordinateFromValue: function(option){
            if (typeOf(option) != 'string') return option;
            option = option.toLowerCase();

            return {
                x: option.test('left') ? 'left'
                    : (option.test('right') ? 'right' : 'center'),
                y: option.test(/upper|top/) ? 'top'
                    : (option.test('bottom') ? 'bottom' : 'center')
            };
        }

    };

    Element.implement({

        position: function(options){
            if (options && (options.x != null || options.y != null)){
                return (original ? original.apply(this, arguments) : this);
            }
            var position = this.setStyle('position', 'absolute').calculatePosition(options);
            return (options && options.returnPos) ? position : this.setStyles(position);
        },

        calculatePosition: function(options){
            return local.getPosition(this, options);
        }

    });

})(Element.prototype.position);


/*
 ---

 script: IframeShim.js

 name: IframeShim

 description: Defines IframeShim, a class for obscuring select lists and flash objects in IE.

 license: MIT-style license

 authors:
 - Aaron Newton

 requires:
 - Core/Element.Event
 - Core/Element.Style
 - Core/Options
 - Core/Events
 - /Element.Position
 - /Class.Occlude

 provides: [IframeShim]

 ...
 */

var IframeShim = new Class({

    Implements: [Options, Events, Class.Occlude],

    options: {
        className: 'iframeShim',
        src: 'javascript:false;document.write("");',
        display: false,
        zIndex: null,
        margin: 0,
        offset: {x: 0, y: 0},
        browsers: (Browser.ie6 || (Browser.firefox && Browser.version < 3 && Browser.Platform.mac))
    },

    property: 'IframeShim',

    initialize: function(element, options){
        this.element = document.id(element);
        if (this.occlude()) return this.occluded;
        this.setOptions(options);
        this.makeShim();
        return this;
    },

    makeShim: function(){
        if (this.options.browsers){
            var zIndex = this.element.getStyle('zIndex').toInt();

            if (!zIndex){
                zIndex = 1;
                var pos = this.element.getStyle('position');
                if (pos == 'static' || !pos) this.element.setStyle('position', 'relative');
                this.element.setStyle('zIndex', zIndex);
            }
            zIndex = ((this.options.zIndex != null || this.options.zIndex === 0) && zIndex > this.options.zIndex) ? this.options.zIndex : zIndex - 1;
            if (zIndex < 0) zIndex = 1;
            this.shim = new Element('iframe', {
                src: this.options.src,
                scrolling: 'no',
                frameborder: 0,
                styles: {
                    zIndex: zIndex,
                    position: 'absolute',
                    border: 'none',
                    filter: 'progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=0)'
                },
                'class': this.options.className
            }).store('IframeShim', this);
            var inject = (function(){
                this.shim.inject(this.element, 'after');
                this[this.options.display ? 'show' : 'hide']();
                this.fireEvent('inject');
            }).bind(this);
            if (!IframeShim.ready) window.addEvent('load', inject);
            else inject();
        } else {
            this.position = this.hide = this.show = this.dispose = Function.from(this);
        }
    },

    position: function(){
        if (!IframeShim.ready || !this.shim) return this;
        var size = this.element.measure(function(){
            return this.getSize();
        });
        if (this.options.margin != undefined){
            size.x = size.x - (this.options.margin * 2);
            size.y = size.y - (this.options.margin * 2);
            this.options.offset.x += this.options.margin;
            this.options.offset.y += this.options.margin;
        }
        this.shim.set({width: size.x, height: size.y}).position({
            relativeTo: this.element,
            offset: this.options.offset
        });
        return this;
    },

    hide: function(){
        if (this.shim) this.shim.setStyle('display', 'none');
        return this;
    },

    show: function(){
        if (this.shim) this.shim.setStyle('display', 'block');
        return this.position();
    },

    dispose: function(){
        if (this.shim) this.shim.dispose();
        return this;
    },

    destroy: function(){
        if (this.shim) this.shim.destroy();
        return this;
    }

});

window.addEvent('load', function(){
    IframeShim.ready = true;
});


/*
 ---

 script: Mask.js

 name: Mask

 description: Creates a mask element to cover another.

 license: MIT-style license

 authors:
 - Aaron Newton

 requires:
 - Core/Options
 - Core/Events
 - Core/Element.Event
 - /Class.Binds
 - /Element.Position
 - /IframeShim

 provides: [Mask]

 ...
 */

var Mask = new Class({

    Implements: [Options, Events],

    Binds: ['position'],

    options: {/*
     onShow: function(){},
     onHide: function(){},
     onDestroy: function(){},
     onClick: function(event){},
     inject: {
     where: 'after',
     target: null,
     },
     hideOnClick: false,
     id: null,
     destroyOnHide: false,*/
        style: {},
        'class': 'mask',
        maskMargins: false,
        useIframeShim: true,
        iframeShimOptions: {}
    },

    initialize: function(target, options){
        this.target = document.id(target) || document.id(document.body);
        this.target.store('mask', this);
        this.setOptions(options);
        this.render();
        this.inject();
    },

    render: function(){
        this.element = new Element('div', {
            'class': this.options['class'],
            id: this.options.id || 'mask-' + String.uniqueID(),
            styles: Object.merge({}, this.options.style, {
                display: 'none'
            }),
            events: {
                click: function(event){
                    this.fireEvent('click', event);
                    if (this.options.hideOnClick) this.hide();
                }.bind(this)
            }
        });

        this.hidden = true;
    },

    toElement: function(){
        return this.element;
    },

    inject: function(target, where){
        where = where || (this.options.inject ? this.options.inject.where : '') || this.target == document.body ? 'inside' : 'after';
        target = target || (this.options.inject && this.options.inject.target) || this.target;

        this.element.inject(target, where);

        if (this.options.useIframeShim){
            this.shim = new IframeShim(this.element, this.options.iframeShimOptions);

            this.addEvents({
                show: this.shim.show.bind(this.shim),
                hide: this.shim.hide.bind(this.shim),
                destroy: this.shim.destroy.bind(this.shim)
            });
        }
    },

    position: function(){
        this.resize(this.options.width, this.options.height);

        this.element.position({
            relativeTo: this.target,
            position: 'topLeft',
            ignoreMargins: !this.options.maskMargins,
            ignoreScroll: this.target == document.body
        });

        return this;
    },

    resize: function(x, y){
        var opt = {
            styles: ['padding', 'border']
        };
        if (this.options.maskMargins) opt.styles.push('margin');

        var dim = this.target.getComputedSize(opt);
        if (this.target == document.body){
            this.element.setStyles({width: 0, height: 0});
            var win = window.getScrollSize();
            if (dim.totalHeight < win.y) dim.totalHeight = win.y;
            if (dim.totalWidth < win.x) dim.totalWidth = win.x;
        }
        this.element.setStyles({
            width: Array.pick([x, dim.totalWidth, dim.x]),
            height: Array.pick([y, dim.totalHeight, dim.y])
        });

        return this;
    },

    show: function(){
        if (!this.hidden) return this;

        window.addEvent('resize', this.position);
        this.position();
        this.showMask.apply(this, arguments);

        return this;
    },

    showMask: function(){
        this.element.setStyle('display', 'block');
        this.hidden = false;
        this.fireEvent('show');
    },

    hide: function(){
        if (this.hidden) return this;

        window.removeEvent('resize', this.position);
        this.hideMask.apply(this, arguments);
        if (this.options.destroyOnHide) return this.destroy();

        return this;
    },

    hideMask: function(){
        this.element.setStyle('display', 'none');
        this.hidden = true;
        this.fireEvent('hide');
    },

    toggle: function(){
        this[this.hidden ? 'show' : 'hide']();
    },

    destroy: function(){
        this.hide();
        this.element.destroy();
        this.fireEvent('destroy');
        this.target.eliminate('mask');
    }

});

Element.Properties.mask = {

    set: function(options){
        var mask = this.retrieve('mask');
        if (mask) mask.destroy();
        return this.eliminate('mask').store('mask:options', options);
    },

    get: function(){
        var mask = this.retrieve('mask');
        if (!mask){
            mask = new Mask(this, this.retrieve('mask:options'));
            this.store('mask', mask);
        }
        return mask;
    }

};

Element.implement({

    mask: function(options){
        if (options) this.set('mask', options);
        this.get('mask').show();
        return this;
    },

    unmask: function(){
        this.get('mask').hide();
        return this;
    }

});


/*
 ---

 script: Spinner.js

 name: Spinner

 description: Adds a semi-transparent overlay over a dom element with a spinnin ajax icon.

 license: MIT-style license

 authors:
 - Aaron Newton

 requires:
 - Core/Fx.Tween
 - Core/Request
 - /Class.refactor
 - /Mask

 provides: [Spinner]

 ...
 */

var Spinner = new Class({

    Extends: Mask,

    Implements: Chain,

    options: {/*
     message: false,*/
        'class': 'spinner',
        containerPosition: {},
        content: {
            'class': 'spinner-content'
        },
        messageContainer: {
            'class': 'spinner-msg'
        },
        img: {
            'class': 'spinner-img'
        },
        fxOptions: {
            link: 'chain'
        }
    },

    initialize: function(target, options){
        this.target = document.id(target) || document.id(document.body);
        this.target.store('spinner', this);
        this.setOptions(options);
        this.render();
        this.inject();

        // Add this to events for when noFx is true; parent methods handle hide/show.
        var deactivate = function(){ this.active = false; }.bind(this);
        this.addEvents({
            hide: deactivate,
            show: deactivate
        });
    },

    render: function(){
        this.parent();

        this.element.set('id', this.options.id || 'spinner-' + String.uniqueID());

        this.content = document.id(this.options.content) || new Element('div', this.options.content);
        this.content.inject(this.element);

        if (this.options.message){
            this.msg = document.id(this.options.message) || new Element('p', this.options.messageContainer).appendText(this.options.message);
            this.msg.inject(this.content);
        }

        if (this.options.img){
            this.img = document.id(this.options.img) || new Element('div', this.options.img);
            this.img.inject(this.content);
        }

        this.element.set('tween', this.options.fxOptions);
    },

    show: function(noFx){
        if (this.active) return this.chain(this.show.bind(this));
        if (!this.hidden){
            this.callChain.delay(20, this);
            return this;
        }

        this.active = true;

        return this.parent(noFx);
    },

    showMask: function(noFx){
        var pos = function(){
            this.content.position(Object.merge({
                relativeTo: this.element
            }, this.options.containerPosition));
        }.bind(this);

        if (noFx){
            this.parent();
            pos();
        } else {
            if (!this.options.style.opacity) this.options.style.opacity = this.element.getStyle('opacity').toFloat();
            this.element.setStyles({
                display: 'block',
                opacity: 0
            }).tween('opacity', this.options.style.opacity);
            pos();
            this.hidden = false;
            this.fireEvent('show');
            this.callChain();
        }
    },

    hide: function(noFx){
        if (this.active) return this.chain(this.hide.bind(this));
        if (this.hidden){
            this.callChain.delay(20, this);
            return this;
        }
        this.active = true;
        return this.parent(noFx);
    },

    hideMask: function(noFx){
        if (noFx) return this.parent();
        this.element.tween('opacity', 0).get('tween').chain(function(){
            this.element.setStyle('display', 'none');
            this.hidden = true;
            this.fireEvent('hide');
            this.callChain();
        }.bind(this));
    },

    destroy: function(){
        this.content.destroy();
        this.parent();
        this.target.eliminate('spinner');
    }

});

Request = Class.refactor(Request, {

    options: {
        useSpinner: false,
        spinnerOptions: {},
        spinnerTarget: false
    },

    initialize: function(options){
        this._send = this.send;
        this.send = function(options){
            var spinner = this.getSpinner();
            if (spinner) spinner.chain(this._send.pass(options, this)).show();
            else this._send(options);
            return this;
        };
        this.previous(options);
    },

    getSpinner: function(){
        if (!this.spinner){
            var update = document.id(this.options.spinnerTarget) || document.id(this.options.update);
            if (this.options.useSpinner && update){
                update.set('spinner', this.options.spinnerOptions);
                var spinner = this.spinner = update.get('spinner');
                ['complete', 'exception', 'cancel'].each(function(event){
                    this.addEvent(event, spinner.hide.bind(spinner));
                }, this);
            }
        }
        return this.spinner;
    }

});

Element.Properties.spinner = {

    set: function(options){
        var spinner = this.retrieve('spinner');
        if (spinner) spinner.destroy();
        return this.eliminate('spinner').store('spinner:options', options);
    },

    get: function(){
        var spinner = this.retrieve('spinner');
        if (!spinner){
            spinner = new Spinner(this, this.retrieve('spinner:options'));
            this.store('spinner', spinner);
        }
        return spinner;
    }

};

Element.implement({

    spin: function(options){
        if (options) this.set('spinner', options);
        this.get('spinner').show();
        return this;
    },

    unspin: function(){
        this.get('spinner').hide();
        return this;
    }

});


/*
 ---

 name: Events.Pseudos

 description: Adds the functionality to add pseudo events

 license: MIT-style license

 authors:
 - Arian Stolwijk

 requires: [Core/Class.Extras, Core/Slick.Parser, More/MooTools.More]

 provides: [Events.Pseudos]

 ...
 */

(function(){

    Events.Pseudos = function(pseudos, addEvent, removeEvent){

        var storeKey = '_monitorEvents:';

        var storageOf = function(object){
            return {
                store: object.store ? function(key, value){
                    object.store(storeKey + key, value);
                } : function(key, value){
                    (object._monitorEvents || (object._monitorEvents = {}))[key] = value;
                },
                retrieve: object.retrieve ? function(key, dflt){
                    return object.retrieve(storeKey + key, dflt);
                } : function(key, dflt){
                    if (!object._monitorEvents) return dflt;
                    return object._monitorEvents[key] || dflt;
                }
            };
        };

        var splitType = function(type){
            if (type.indexOf(':') == -1 || !pseudos) return null;

            var parsed = Slick.parse(type).expressions[0][0],
                parsedPseudos = parsed.pseudos,
                l = parsedPseudos.length,
                splits = [];

            while (l--){
                var pseudo = parsedPseudos[l].key,
                    listener = pseudos[pseudo];
                if (listener != null) splits.push({
                    event: parsed.tag,
                    value: parsedPseudos[l].value,
                    pseudo: pseudo,
                    original: type,
                    listener: listener
                });
            }
            return splits.length ? splits : null;
        };

        return {

            addEvent: function(type, fn, internal){
                var split = splitType(type);
                if (!split) return addEvent.call(this, type, fn, internal);

                var storage = storageOf(this),
                    events = storage.retrieve(type, []),
                    eventType = split[0].event,
                    args = Array.slice(arguments, 2),
                    stack = fn,
                    self = this;

                split.each(function(item){
                    var listener = item.listener,
                        stackFn = stack;
                    if (listener == false) eventType += ':' + item.pseudo + '(' + item.value + ')';
                    else stack = function(){
                        listener.call(self, item, stackFn, arguments, stack);
                    };
                });

                events.include({type: eventType, event: fn, monitor: stack});
                storage.store(type, events);

                if (type != eventType) addEvent.apply(this, [type, fn].concat(args));
                return addEvent.apply(this, [eventType, stack].concat(args));
            },

            removeEvent: function(type, fn){
                var split = splitType(type);
                if (!split) return removeEvent.call(this, type, fn);

                var storage = storageOf(this),
                    events = storage.retrieve(type);
                if (!events) return this;

                var args = Array.slice(arguments, 2);

                removeEvent.apply(this, [type, fn].concat(args));
                events.each(function(monitor, i){
                    if (!fn || monitor.event == fn) removeEvent.apply(this, [monitor.type, monitor.monitor].concat(args));
                    delete events[i];
                }, this);

                storage.store(type, events);
                return this;
            }

        };

    };

    var pseudos = {

        once: function(split, fn, args, monitor){
            fn.apply(this, args);
            this.removeEvent(split.event, monitor)
                .removeEvent(split.original, fn);
        },

        throttle: function(split, fn, args){
            if (!fn._throttled){
                fn.apply(this, args);
                fn._throttled = setTimeout(function(){
                    fn._throttled = false;
                }, split.value || 250);
            }
        },

        pause: function(split, fn, args){
            clearTimeout(fn._pause);
            fn._pause = fn.delay(split.value || 250, this, args);
        }

    };

    Events.definePseudo = function(key, listener){
        pseudos[key] = listener;
        return this;
    };

    Events.lookupPseudo = function(key){
        return pseudos[key];
    };

    var proto = Events.prototype;
    Events.implement(Events.Pseudos(pseudos, proto.addEvent, proto.removeEvent));

    ['Request', 'Fx'].each(function(klass){
        if (this[klass]) this[klass].implement(Events.prototype);
    });

})();


/*
 ---

 name: Element.Event.Pseudos

 description: Adds the functionality to add pseudo events for Elements

 license: MIT-style license

 authors:
 - Arian Stolwijk

 requires: [Core/Element.Event, Core/Element.Delegation, Events.Pseudos]

 provides: [Element.Event.Pseudos, Element.Delegation]

 ...
 */

(function(){

    var pseudos = {relay: false},
        copyFromEvents = ['once', 'throttle', 'pause'],
        count = copyFromEvents.length;

    while (count--) pseudos[copyFromEvents[count]] = Events.lookupPseudo(copyFromEvents[count]);

    DOMEvent.definePseudo = function(key, listener){
        pseudos[key] = listener;
        return this;
    };

    var proto = Element.prototype;
    [Element, Window, Document].invoke('implement', Events.Pseudos(pseudos, proto.addEvent, proto.removeEvent));

})();


/*
 ---

 script: Form.Request.js

 name: Form.Request

 description: Handles the basic functionality of submitting a form and updating a dom element with the result.

 license: MIT-style license

 authors:
 - Aaron Newton

 requires:
 - Core/Request.HTML
 - /Class.Binds
 - /Class.Occlude
 - /Spinner
 - /String.QueryString
 - /Element.Delegation

 provides: [Form.Request]

 ...
 */

if (!window.Form) window.Form = {};

(function(){

    Form.Request = new Class({

        Binds: ['onSubmit', 'onFormValidate'],

        Implements: [Options, Events, Class.Occlude],

        options: {/*
         onFailure: function(){},
         onSuccess: function(){}, // aliased to onComplete,
         onSend: function(){}*/
            requestOptions: {
                evalScripts: true,
                useSpinner: true,
                emulation: false,
                link: 'ignore'
            },
            sendButtonClicked: true,
            extraData: {},
            resetForm: true
        },

        property: 'form.request',

        initialize: function(form, target, options){
            this.element = document.id(form);
            if (this.occlude()) return this.occluded;
            this.setOptions(options)
                .setTarget(target)
                .attach();
        },

        setTarget: function(target){
            this.target = document.id(target);
            if (!this.request){
                this.makeRequest();
            } else {
                this.request.setOptions({
                    update: this.target
                });
            }
            return this;
        },

        toElement: function(){
            return this.element;
        },

        makeRequest: function(){
            var self = this;
            this.request = new Request.HTML(Object.merge({
                update: this.target,
                emulation: false,
                spinnerTarget: this.element,
                method: this.element.get('method') || 'post'
            }, this.options.requestOptions)).addEvents({
                    success: function(tree, elements, html, javascript){
                        ['complete', 'success'].each(function(evt){
                            self.fireEvent(evt, [self.target, tree, elements, html, javascript]);
                        });
                    },
                    failure: function(){
                        self.fireEvent('complete', arguments).fireEvent('failure', arguments);
                    },
                    exception: function(){
                        self.fireEvent('failure', arguments);
                    }
                });
            return this.attachReset();
        },

        attachReset: function(){
            if (!this.options.resetForm) return this;
            this.request.addEvent('success', function(){
                Function.attempt(function(){
                    this.element.reset();
                }.bind(this));
                if (window.OverText) OverText.update();
            }.bind(this));
            return this;
        },

        attach: function(attach){
            var method = (attach != false) ? 'addEvent' : 'removeEvent';
            this.element[method]('click:relay(button, input[type=submit])', this.saveClickedButton.bind(this));

            var fv = this.element.retrieve('validator');
            if (fv) fv[method]('onFormValidate', this.onFormValidate);
            else this.element[method]('submit', this.onSubmit);

            return this;
        },

        detach: function(){
            return this.attach(false);
        },

        //public method
        enable: function(){
            return this.attach();
        },

        //public method
        disable: function(){
            return this.detach();
        },

        onFormValidate: function(valid, form, event){
            //if there's no event, then this wasn't a submit event
            if (!event) return;
            var fv = this.element.retrieve('validator');
            if (valid || (fv && !fv.options.stopOnFailure)){
                event.stop();
                this.send();
            }
        },

        onSubmit: function(event){
            var fv = this.element.retrieve('validator');
            if (fv){
                //form validator was created after Form.Request
                this.element.removeEvent('submit', this.onSubmit);
                fv.addEvent('onFormValidate', this.onFormValidate);
                this.element.validate();
                return;
            }
            if (event) event.stop();
            this.send();
        },

        saveClickedButton: function(event, target){
            var targetName = target.get('name');
            if (!targetName || !this.options.sendButtonClicked) return;
            this.options.extraData[targetName] = target.get('value') || true;
            this.clickedCleaner = function(){
                delete this.options.extraData[targetName];
                this.clickedCleaner = function(){};
            }.bind(this);
        },

        clickedCleaner: function(){},

        send: function(){
            var str = this.element.toQueryString().trim(),
                data = Object.toQueryString(this.options.extraData);

            if (str) str += "&" + data;
            else str = data;

            this.fireEvent('send', [this.element, str.parseQueryString()]);
            this.request.send({
                data: str,
                url: this.options.requestOptions.url || this.element.get('action')
            });
            this.clickedCleaner();
            return this;
        }

    });

    Element.implement('formUpdate', function(update, options){
        var fq = this.retrieve('form.request');
        if (!fq){
            fq = new Form.Request(this, update, options);
        } else {
            if (update) fq.setTarget(update);
            if (options) fq.setOptions(options).makeRequest();
        }
        fq.send();
        return this;
    });

})();

